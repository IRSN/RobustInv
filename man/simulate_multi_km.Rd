% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulate_multi_km.R
\name{simulate_multi_km}
\alias{simulate_multi_km}
\title{Independent simulations in several batches of points}
\usage{
simulate_multi_km(object, nsim = 1, nbatch = 1, seed = NULL,
  newdata = NULL, cond = FALSE, nugget.sim = 0, checkNames = TRUE,
  type = "UK", pn.only = FALSE)
}
\arguments{
\item{object}{The current kriging model. km object.}

\item{nsim}{Integer. Number of Gaussian process simulation to perform for each batch of p points.}

\item{nbatch}{Integer. The number n of batches.}

\item{seed}{The random seed. For repeatability.}

\item{newdata}{Matrix of dimension (n*p) x d containing the n different batches of p points where 
the simulations are performed. The number of rows must be a multiple of n.}

\item{cond}{Boolean. When set to TRUE, the simulations are conditional simulations.}

\item{nugget.sim}{An optimal additional nugget to the simulations.}

\item{checkNames}{Boolean. See the documentation of the \code{predict} function of the DiceKriging package.}

\item{type}{See the documentation of the \code{predict} function of the DiceKriging package.}

\item{pn.only}{Boolean. When set to TRUE, only the conditional simulations are returned, and other auxiliary results are not returned.}
}
\value{
A list with the following fields. (i) allsimu: (n*p) x nsim matrix. The first p rows correspond 
to the nsim simulations (each simulation being a column) associated to batch 1. Next p rows are 
for batch 2 and so on. (ii) allKn.inv: (n*p) x p matrix containing n different p x p matrices. Matrix number i is the inverse 
of the p x p non-conditional covariance matrix of the p simulation points associated to the 
batch i. (iii) allmn: n*p array with the kriging means of all n*p points stored in newdata.
}
\description{
Performs conditional or non-conditional simulations in n different batches of p points.
}
\examples{
library(KrigInv)
library(randtoolbox)
myfun <- branin_robinv
d <- 3

set.seed(8)

n0 <- 30
T <- 10
opt.index <- c(3)
inv.index <- c(1,2)
lower <- rep(0,times=d)
upper <- rep(1,times=d)
d.inv <- length(inv.index);d.opt <- length(opt.index)
lower.inv <- lower[inv.index];upper.inv <- upper[inv.index]
lower.opt <- lower[opt.index];upper.opt <- upper[opt.index]

design <- matrix(runif(d*n0),nrow=n0)
response <- myfun(design)
model <- km(formula = ~1,design = design,response = response,covtype = "matern3_2")

p <- n.optpoints <- 40
nsimu <- 1000

n <- n.points <- 50 # number of integration points
inv.integration.points <- t(lower.inv + t(sobol(n=n.points,dim=d.inv))*(upper.inv-lower.inv))
opt.simulation.points <- t(lower.opt + t(sobol(n=n.optpoints,dim=d.opt))*(upper.opt-lower.opt))

allsimupoints <- matrix(c(0) , nrow=(n*p) , ncol = d)

for(i in 1:n){
  # deal with integration point i
  index.first <- 1+(i-1)*p
  index.last <- i*p
  
  inv.point <- inv.integration.points[i,]
  simu_points <- matrix(c(0),nrow=p,ncol=d)
  
  for(alpha in 1:length(opt.index)) simu_points[,opt.index[alpha]] <- opt.simulation.points[,alpha]
  for(alpha in 1:length(inv.index)) simu_points[,inv.index[alpha]] <- as.numeric(inv.point[alpha])
  
  allsimupoints[index.first:index.last ,] <- simu_points
}
\dontrun{
result <- simulate_multi_km(object=model,nsim=nsimu,nbatch = n, newdata=allsimupoints,
                            cond=TRUE,checkNames=FALSE,type="UK",seed=NULL,
                            pn.only=FALSE)
}
}
\author{
Clement Chevalier \email{clement.chevalier@unine.ch}
}
