% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_pn_and_simulate.R
\name{get_pn_and_simulate}
\alias{get_pn_and_simulate}
\title{Excursion probability through conditional simulations}
\usage{
get_pn_and_simulate(inv.integration.points, opt.simulation.points, nsimu,
  model, T, opt.index, inv.index, lower, upper, seed = NULL,
  lowmemory = FALSE, subsample_simupoints = FALSE, p = NULL,
  unscale = FALSE, pn.only = FALSE)
}
\arguments{
\item{inv.integration.points}{Matrix of dimension n x dinv where n is the number of integration
points and dinv the number of controlled parameters.}

\item{opt.simulation.points}{Matrix with dopt columns where 
dopt the number of nuisance parameters. Each row is a of simulation points or 
candidate simulation point.}

\item{nsimu}{Integer. Number of conditional Gaussian process simulation to perform per integration points.}

\item{model}{The current kriging model. km object.}

\item{T}{Target threshold.}

\item{opt.index}{Array with integers corresponding to the indices of the nuisance parameters.}

\item{inv.index}{Array with integers corresponding to the indices of the controlled parameters.}

\item{lower}{Array of size d. Lower bound of the input domain.}

\item{upper}{Array of size d. Upper bound of the input domain.}

\item{seed}{The random seed. For repeatability.}

\item{lowmemory}{Boolean. When set to TRUE some precomputations on kriging update are not performed.}

\item{subsample_simupoints}{Boolean. When set to TRUE, p simulation points will be selected among 
opt.simulation.points.}

\item{p}{Integer. Applies only if \code{subsample_simupoints = TRUE}. In that case, this is the number
of simulation points which is subsampled (without replacement) among the candidates opt.simulation.points.}

\item{unscale}{Boolean. When set to TRUE, scaling is applied to the simulation points.}

\item{pn.only}{Boolean. When set to TRUE, only the excursion probability is returned.}
}
\value{
A list with the following fields. (i) pn: array of size n containing the excursion probabilities 
of each integration points. For each point, these excursion probabilities are based on nsimu 
conditional simulations. (ii) allsimu: p x (nsimu*n) matrix containing the conditional simulations.
The first nsimu columns are the nsimu simulations in p points for the first integration point, 
the next nsimu columns are linked to the next integration point and so on. 
(iii) allsimucentered: p x (nsimu*n) matrix containing the later simulations centered by 
substracting the kriging mean of the points where the simulations are performed.
(iv) allsimupoints: (n*p) x d matrix containing all the points where simulations are performed. 
The first p rows correspond to the simulation points linked to the first integration points, and so on.
In case \code{subsample_simupoints = TRUE}, these points are 'well-chosen' among the candidates.
(v) inv.integration.points: n x d.inv matrix containing the integration points passed with the 
argument inv.integration.points.
(vi) allprecomp: when the argument \code{lowmemory} is set to \code{FALSE}, the function 
\code{precomputeUpdateData} from the KrigInv package is called on the (possibly: 'well chosen') 
simulation points. The result is a list with several fields which help to compute quickly 
updated kriging means and variances. See, the documentation in the KrigInv 
package.
(vii) allKn.inv: (n*p) x p matrix containing n different p x p matrices. Matrix number i is the inverse 
of the p x p non-conditional covariance matrix of the p simulation points associated to the 
integration point i. 
(viii) allmn: n*p array with the kriging means of all n*p simulation points stored in field (iv).
}
\description{
Compute excursion probabilities for integration points using 
conditional simulations in a set of (possibly: well-chosen) simulation points.
}
\examples{
library(KrigInv)
library(randtoolbox)
myfun <- branin_robinv
d <- 3

set.seed(8)

n0 <- 30
T <- 10
opt.index <- c(3)
inv.index <- c(1,2)
lower <- rep(0,times=d)
upper <- rep(1,times=d)
d.inv <- length(inv.index);d.opt <- length(opt.index)
lower.inv <- lower[inv.index];upper.inv <- upper[inv.index]
lower.opt <- lower[opt.index];upper.opt <- upper[opt.index]

design <- matrix(runif(d*n0),nrow=n0)
response <- myfun(design)
model <- km(formula = ~1,design = design,response = response,covtype = "matern3_2")

n.optpoints <- 40
n.optpoints.candidates <- 200
nsimu <- 1000

n.points <- 50 # number of integration points
inv.integration.points <- t(lower.inv + t(sobol(n=n.points,dim=d.inv))*(upper.inv-lower.inv))
opt.simulation.points <- t(lower.opt + t(sobol(n=n.optpoints.candidates,dim=d.opt))*(upper.opt-lower.opt))

\dontrun{
result <- get_pn_and_simulate(inv.integration.points=inv.integration.points,
   opt.simulation.points=opt.simulation.points,nsimu=nsimu,model=model,T=T,
   opt.index=opt.index,inv.index=inv.index,lower=lower,upper=upper,
   lowmemory = TRUE,subsample_simupoints = TRUE,unscale=FALSE,
   p = n.optpoints)
}
}
\author{
Clement Chevalier \email{clement.chevalier@unine.ch}
}
