% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unscalingFun.R
\name{unscalingFun}
\alias{unscalingFun}
\title{Unscaling function applied to all the dimensions}
\usage{
unscalingFun(mat, model = NULL, allknots = NULL, alleta = NULL,
  indices = NULL, standardize = FALSE, lower = NULL, upper = NULL)
}
\arguments{
\item{mat}{Matrix with values to be unscaled}

\item{model}{km object containing knots and eta's. If provided, the arguments allknots and alleta are ignored.}

\item{allknots}{List of arrays obtained from the field \code{model@covariance@knots} of a \code{km} object}

\item{alleta}{List of arrays obtained from the field \code{model@covariance@eta} of a km object}

\item{indices}{Array containing the indices of the dimensions to rescale.}

\item{standardize}{If the initial values in the columns of mat are not in [0,S], 
with S the integral of the piecewise linear function equal to eta at points knots, 
then there is the possibility to rescale the values y by indicating in which interval they are.}

\item{lower}{If \code{standardize=TRUE}, this is an array of lower bounds.}

\item{upper}{If \code{standardize=TRUE}, this is an array of upper bounds.}
}
\value{
A rescaled matrix with the same size.
}
\description{
Unscaling the coordinates of points in dimension d
}
\details{
There are two possible ways to use this function. If the number of columns of mat 
is not equal to \code{d = model@d} (i.e. the number of dimensions), we assume that mat 
is allready a submatrix of some bigger matrix with d columns. In that case, all the columns 
of mat are rescaled an so \code{length(indices)} Must be equal to the number of columns of mat. 
The second way to use the function is to have a matrix mat with the same number of columns as d. 
In that case only some (or all) columns of mat will be rescaled, depending on the values of indices. 
If indices is missing, all the columns are rescaled.
}
\examples{
library(DiceKriging)
myfun <- function(x) return(-1 * branin_robinv(x))
d <- 4

set.seed(8)

n0 <- 40
T <- -10
opt.index <- c(3,4)
inv.index <- c(1,2)
lower <- rep(0,times=d)
upper <- rep(1,times=d)

design <- matrix(runif(d*n0),nrow=n0)
response <- myfun(design)

knots.number <- c(3,0,2,2)
knots <- generate_knots(knots.number = knots.number , d = d)

model <- km(formula = ~1,design = design,response = response,covtype = "matern3_2",scaling = TRUE,knots = knots)
allknots <- model@covariance@knots
alleta <- model@covariance@eta

# generates a sequence of points in dimension 4:
myrands <- matrix( runif(2000),ncol=4  )

result <- unscalingFun(mat = myrands[,1:2], allknots =  allknots,alleta = alleta,indices = c(1,2),standardize = TRUE , lower = lower,upper = upper)

result2 <- unscalingFun(mat = myrands,      allknots =  allknots,alleta = alleta,indices = c(1,2),standardize = TRUE , lower = lower,upper = upper)

# result and result2 are the same
}
\author{
Clement Chevalier \email{clement.chevalier@unine.ch}
}
